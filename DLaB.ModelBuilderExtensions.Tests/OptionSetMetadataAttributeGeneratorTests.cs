using DLaB.ModelBuilderExtensions.Entity;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.CodeDom;
using System.Text;

namespace DLaB.ModelBuilderExtensions.Tests
{
    [TestClass]
    public class OptionSetMetadataAttributeGeneratorTests
    {
        [TestMethod]
        public void TestGeneration()
        {
            var codeCompileUnit = new CodeCompileUnit();
            var codeNamespace = new CodeNamespace("Test");
            codeCompileUnit.Namespaces.Add(codeNamespace);
            var sut = new OptionSetMetadataAttributeGenerator();

            sut.CustomizeCodeDom(codeCompileUnit, null);

            var provider = new Microsoft.CSharp.CSharpCodeProvider();
            var stringBuilder = new StringBuilder();
            var stringWriter = new System.IO.StringWriter(stringBuilder);
            provider.GenerateCodeFromCompileUnit(codeCompileUnit, stringWriter, new System.CodeDom.Compiler.CodeGeneratorOptions
            {
                IndentString = "\t"
            });
            var code = stringBuilder.ToString();
            Assert.AreEqual(Expected, code.Trim());
        }

        const string Expected = @"//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Test {
	
	
	/// <summary>
	/// Attribute to handle storing the OptionSet's Metadata.
	/// </summary>
	[System.AttributeUsageAttribute(System.AttributeTargets.Field)]
	public sealed class OptionSetMetadataAttribute : System.Attribute {
		
		private object[] _nameObjects;
		
		private System.Collections.Generic.Dictionary<int, string> _names;
		
		/// <summary>
		/// Color of the OptionSetValue.
		/// </summary>
		public string Color { get; set; }
		/// <summary>
		/// Description of the OptionSetValue.
		/// </summary>
		public string Description { get; set; }
		/// <summary>
		/// Display order index of the OptionSetValue.
		/// </summary>
		public int DisplayIndex { get; set; }
		/// <summary>
		/// External value of the OptionSetValue.
		/// </summary>
		public string ExternalValue { get; set; }
		/// <summary>
		/// Name of the OptionSetValue.
		/// </summary>
		public string Name { get; set; }
		/// <summary>
		/// Names of the OptionSetValue.
		/// </summary>
		public System.Collections.Generic.Dictionary<int, string> Names
		{
			get
			{
				return _names ?? (_names = CreateNames());
			} 
			set
			{
				_names = value;
				if (value == null)
				{
				    _nameObjects = new object[0];
				}
				else
				{
				    _nameObjects = null;
				}
			}
		}
		
		/// <summary>
		/// Initializes a new instance of the <see cref=""OptionSetMetadataAttribute""/> class.
		/// </summary>
		/// <param name=""name"">Name of the value.</param>
		/// <param name=""displayIndex"">Display order index of the value.</param>
		/// <param name=""color"">Color of the value.</param>
		/// <param name=""description"">Description of the value.</param>
		/// <param name=""externalValue"">External value of the value.</param>
		/// <param name=""names"">Names of the value.</param>
		public OptionSetMetadataAttribute(string name, int displayIndex, string color = null, string description = null, string externalValue = null, params object[] names) {
			this.Color = color;
			this.Description = description;
			this._nameObjects = names;
			this.ExternalValue = externalValue;
			this.DisplayIndex = displayIndex;
			this.Name = name;
		}
		
		private System.Collections.Generic.Dictionary<int, string> CreateNames() {
			System.Collections.Generic.Dictionary<int, string> names = new System.Collections.Generic.Dictionary<int, string>();
			for (int i = 0; (i < _nameObjects.Length); i = (i + 2)) {
				names.Add(((int)(_nameObjects[i])), ((string)(_nameObjects[(i + 1)])));
			}
			return names;
		}
	}
	
	/// <summary>
	/// Extension class to handle retrieving of OptionSetMetadataAttribute.
	/// </summary>
	public class OptionSetExtension {
		
		/// <summary>
		/// Returns the OptionSetMetadataAttribute for the given enum value
		/// </summary>
		/// <typeparam name=""T"">OptionSet Enum Type</typeparam>
		/// <param name=""value"">Enum Value with OptionSetMetadataAttribute</param>
		public static OptionSetMetadataAttribute GetMetadata<T>(this T value)
			where T :  struct, System.IConvertible {
			System.Type enumType = typeof(T);
			if (!enumType.IsEnum) {
				throw new System.ArgumentException(""T must be an enum!"");
			}
			System.Reflection.MemberInfo[] members = enumType.GetMember(value.ToString());
			for (int i = 0; (i < members.Length); i++
			) {
				System.Attribute attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(members[i], typeof(OptionSetMetadataAttribute));
				if (attribute != null) {
					return ((OptionSetMetadataAttribute)(attribute));
				}
			}
			throw new System.ArgumentException(""T must be an enum adorned with an OptionSetMetadataAttribute!"");
		}
	}
}";
    }
}
